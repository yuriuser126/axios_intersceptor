# Axios 인터셉터 데모 - 상세 사용 가이드

이 문서는 팀원들이 이 데모 프로젝트를 이해하고 사용하는 방법을 단계별로 설명합니다.

## 📋 목차

1. [프로젝트 개요](#프로젝트-개요)
2. [실행 방법](#실행-방법)
3. [기능 테스트 방법](#기능-테스트-방법)
4. [코드 이해하기](#코드-이해하기)
5. [실제 프로젝트 적용 방법](#실제-프로젝트-적용-방법)

---

## 프로젝트 개요

### 이 프로젝트는 무엇인가요?

axios 인터셉터를 사용하여 다음을 자동으로 처리하는 데모 프로젝트입니다:

1. **자동 토큰 추가**: 모든 API 요청에 Authorization 헤더 자동 추가
2. **자동 토큰 갱신**: 401 에러 발생 시 refresh token으로 자동 재발급 후 재요청
3. **전역 에러 처리**: 404/500 에러 발생 시 에러 페이지로 자동 리다이렉트

### 왜 필요한가요?

- **개발자 편의성**: 매번 토큰을 수동으로 추가할 필요 없음
- **사용자 경험**: 토큰 만료 시에도 자동으로 처리되어 끊김 없이 사용 가능
- **코드 일관성**: 모든 API 호출에서 동일한 에러 처리 로직 적용

---

## 실행 방법

### 1단계: 프로젝트 준비

```bash
# 프로젝트 폴더로 이동
cd "/Users/yuri/Desktop/axios 인터셉터"

# 의존성 설치 (처음 한 번만)
npm install

# 개발 서버 실행
npm run dev
```

### 2단계: 브라우저 접속

브라우저에서 `http://localhost:3000` 접속

화면이 정상적으로 보이면 준비 완료!

---

## 기능 테스트 방법

### 테스트 1: 정상 API 호출

**목적**: 기본적인 API 호출이 정상적으로 작동하는지 확인

**단계**:
1. 상단의 "토큰 입력" 섹션에서
   - Access Token: `demo-access` 입력
   - Refresh Token: `demo-refresh` 입력
2. "토큰 저장" 버튼 클릭
3. 하단의 "API 분리 호출 데모" 섹션에서
   - "본사 ERP" 카드의 "정상 호출" 버튼 클릭
4. **결과 확인**:
   - 버튼 옆의 상태가 `success`로 변경됨
   - 콘솔에 정상 응답 로그 확인 가능

**왜 이렇게 동작하나요?**
- 요청 인터셉터가 자동으로 `Authorization: Bearer demo-access` 헤더를 추가
- API 서버가 정상 응답을 반환
- TanStack Query가 응답을 캐싱하고 상태를 업데이트

---

### 테스트 2: 401 토큰 만료 처리 (핵심 기능!)

**목적**: 토큰이 만료되었을 때 자동으로 refresh하고 재요청하는지 확인

**단계**:
1. "토큰 입력" 섹션에서
   - Access Token: `expired` 입력 (⚠️ 중요: 정확히 "expired" 입력)
   - Refresh Token: `demo-refresh` 입력
2. "토큰 저장" 버튼 클릭
3. "본사 ERP" 카드의 "🔵 401" 버튼 클릭
4. **결과 확인**:
   - 브라우저 콘솔을 열어서 확인 (F12 → Console 탭)
   - 다음과 같은 과정이 진행됩니다:
     ```
     1. API 요청 → 401 에러 발생
     2. [인터셉터] refresh token으로 새 토큰 발급 중...
     3. [인터셉터] 새 토큰으로 원래 요청 재시도
     4. ✅ 성공 알림 표시
     ```
   - 성공 알림이 표시되면 정상 작동!

**왜 이렇게 동작하나요?**
1. API 서버가 Authorization 헤더에 "expired"가 포함되어 있으면 401 반환
2. 응답 인터셉터가 401을 감지
3. `refreshAccessToken()` 함수로 새 토큰 발급
4. 실패한 요청을 새 토큰으로 자동 재시도
5. 성공 시 정상 응답 반환

**중요 포인트**:
- 여러 API를 동시에 호출해도 refresh는 **한 번만** 실행됩니다
- refresh가 완료되면 대기 중인 모든 요청이 새 토큰으로 재시도됩니다
- 이는 `isRefreshing` 플래그와 `refreshQueue`로 구현됩니다

---

### 테스트 3: 404 에러 처리

**목적**: 404 에러 발생 시 에러 페이지로 자동 리다이렉트되는지 확인

**단계**:
1. "본사 ERP" 카드의 "🔴 404" 버튼 클릭
2. **결과 확인**:
   - 자동으로 `/error` 페이지로 이동
   - 에러 페이지에 다음 정보 표시:
     - 에러 상태: 404
     - 발생 API: HQ-ERP
     - 에러 메시지: "요청한 리소스를 찾을 수 없습니다."

**왜 이렇게 동작하나요?**
1. API 서버가 404 에러 반환
2. 응답 인터셉터가 404를 감지 (401이 아니므로 refresh 시도 안 함)
3. `handleGlobalError()` 함수 호출
4. `window.location.href = '/error?status=404&api=HQ-ERP'` 로 리다이렉트
5. 에러 페이지가 쿼리 파라미터를 읽어서 정보 표시

---

### 테스트 4: 500 에러 처리

**목적**: 500 에러 발생 시 에러 페이지로 자동 리다이렉트되는지 확인

**단계**:
1. "고객 앱" 카드의 "🟠 500" 버튼 클릭
2. **결과 확인**:
   - 자동으로 `/error` 페이지로 이동
   - 에러 페이지에 다음 정보 표시:
     - 에러 상태: 500
     - 발생 API: Client-App
     - 에러 메시지: "서버에서 오류가 발생했습니다."

**404와 500의 차이점**:
- 둘 다 에러 페이지로 리다이렉트되지만, 에러 메시지가 다릅니다
- 404: "요청한 리소스를 찾을 수 없습니다."
- 500: "서버에서 오류가 발생했습니다."

---

## 코드 이해하기

### 핵심 파일: `src/lib/axios.ts`

이 파일이 전체 인터셉터 로직의 핵심입니다.

#### 1. 요청 인터셉터 (Request Interceptor)

```typescript
instance.interceptors.request.use((config) => {
  const { accessToken } = useAuthStore.getState();
  if (accessToken) {
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${accessToken}`
    };
  }
  return config;
});
```

**동작 원리**:
- 모든 API 요청이 나가기 **전에** 실행됩니다
- Zustand 스토어에서 `accessToken`을 가져옵니다
- 있으면 `Authorization: Bearer {token}` 헤더를 자동으로 추가합니다
- 개발자는 매번 헤더를 추가할 필요가 없습니다!

**예시**:
```typescript
// 개발자가 작성하는 코드
const response = await hqApi.get("/summary");

// 실제로는 다음과 같이 헤더가 자동 추가됨
// GET /api/hq-erp/summary
// Headers: { Authorization: "Bearer demo-access" }
```

#### 2. 응답 인터셉터 - 401 처리

```typescript
if (status === 401 && !originalConfig._retry) {
  originalConfig._retry = true; // 무한 재시도 방지
  
  if (!isRefreshing) {
    // refresh 실행
    const newToken = await refreshAccessToken();
    // 새 토큰으로 재요청
  }
}
```

**동작 원리**:
1. API 응답이 401이면 인터셉터가 감지
2. `_retry` 플래그로 이미 재시도한 요청인지 확인 (무한 루프 방지)
3. `isRefreshing`이 false면 (첫 번째 401 요청이면):
   - refresh token으로 새 access token 발급
   - 스토어에 새 토큰 저장
   - 대기 중인 모든 요청에 새 토큰 전달
4. 새 토큰으로 원래 요청 재시도

**중복 refresh 방지 메커니즘**:
```typescript
let isRefreshing = false;  // 현재 refresh 진행 중인지
let refreshQueue = [];     // refresh 완료를 기다리는 요청들

// 첫 번째 401 요청
if (!isRefreshing) {
  isRefreshing = true;
  // refresh 실행...
  isRefreshing = false;
}

// 두 번째 401 요청 (동시에 발생)
// isRefreshing이 true이므로 refresh 실행 안 함
// refreshQueue에 등록하여 새 토큰을 기다림
```

#### 3. 응답 인터셉터 - 404/500 처리

```typescript
// 401이 아닌 다른 에러
handleGlobalError(error, apiName);
```

**동작 원리**:
1. 401이 아닌 에러(404, 500 등)는 `handleGlobalError()` 함수로 처리
2. 에러 페이지로 리다이렉트: `/error?status={status}&api={apiName}`
3. 에러 페이지가 쿼리 파라미터를 읽어서 정보 표시

---

## 실제 프로젝트 적용 방법

### 1. refreshAccessToken 함수 수정

현재는 데모용으로 mock 응답을 반환하지만, 실제로는 refresh API를 호출해야 합니다:

```typescript
// 현재 (데모용)
async function refreshAccessToken() {
  await new Promise((resolve) => setTimeout(resolve, 400));
  return "new-access-token";
}

// 실제 프로젝트에서는
async function refreshAccessToken() {
  const { refreshToken } = useAuthStore.getState();
  if (!refreshToken) {
    throw new Error("Refresh token not found");
  }
  
  try {
    // refresh API 호출
    const response = await axios.post('/api/auth/refresh', {
      refreshToken
    });
    
    // 새 토큰 저장
    useAuthStore.getState().setTokens({
      accessToken: response.data.accessToken,
      refreshToken: response.data.refreshToken // 새 refresh token도 받을 수 있음
    });
    
    return response.data.accessToken;
  } catch (error) {
    // refresh 실패 시 로그인 페이지로 리다이렉트
    useAuthStore.getState().clearTokens();
    window.location.href = '/login';
    throw error;
  }
}
```

### 2. API 클라이언트 추가

새로운 API를 추가하려면:

```typescript
// src/lib/axios.ts
const API_BASES = {
  hqErp: "/api/hq-erp",
  clientApp: "/api/client-app",
  vendorErp: "/api/vendor-erp",
  newApi: "/api/new-api"  // 새 API 추가
};

// 새 인스턴스 생성
export const newApi = createApiClient(API_BASES.newApi, "New-API");
```

### 3. 사용 예시

```typescript
// src/api/example.ts
import { hqApi } from "@/lib/axios";

// 정상 호출
export async function getSummary() {
  const { data } = await hqApi.get("/summary");
  return data;
}

// 401 발생 시 자동으로 refresh 후 재요청
// 404/500 발생 시 자동으로 /error 페이지로 리다이렉트
// 개발자는 별도로 처리할 필요 없음!
```

---

## 자주 묻는 질문 (FAQ)

### Q1: 401이 발생하면 무조건 refresh를 시도하나요?

**A**: 네, 하지만 한 번만 시도합니다. `_retry` 플래그로 무한 재시도를 방지합니다. refresh가 실패하면 에러를 반환합니다.

### Q2: 여러 API를 동시에 호출할 때 401이 발생하면?

**A**: `isRefreshing` 플래그와 `refreshQueue`를 사용하여 refresh는 **한 번만** 실행하고, 모든 요청이 새 토큰을 받아서 재시도합니다.

**예시**:
```
시간: 0ms  - API 1 호출 → 401 발생
시간: 10ms - API 2 호출 → 401 발생
시간: 20ms - API 3 호출 → 401 발생

→ refresh는 한 번만 실행 (API 1이 실행)
→ API 2, 3은 refreshQueue에 등록
→ refresh 완료 후 모든 API가 새 토큰으로 재시도
```

### Q3: 404/500도 자동으로 재시도하나요?

**A**: 아니요, 404/500은 재시도하지 않고 바로 에러 페이지로 리다이렉트합니다. 401만 자동으로 refresh 후 재시도합니다.

### Q4: 토큰이 없으면 어떻게 되나요?

**A**: 요청 인터셉터에서 토큰이 없으면 Authorization 헤더를 추가하지 않습니다. API 서버가 토큰이 필요하면 401을 반환하고, 그때 refresh를 시도합니다.

### Q5: refresh가 실패하면?

**A**: `refreshAccessToken()` 함수에서 에러가 발생하면:
1. 스토어의 토큰을 모두 초기화
2. 대기 중인 모든 요청에 null을 전달하여 실패 처리
3. `handleGlobalError()`로 전역 에러 처리

실제 프로젝트에서는 로그인 페이지로 리다이렉트하는 것이 좋습니다.

---

## 마무리

이 데모 프로젝트를 통해 다음을 이해할 수 있습니다:

1. ✅ axios 인터셉터의 기본 사용법
2. ✅ 요청 인터셉터로 자동 헤더 추가
3. ✅ 응답 인터셉터로 401 자동 처리
4. ✅ 전역 에러 처리 및 리다이렉트
5. ✅ 여러 API 클라이언트 분리 방법

**다음 단계**:
- 실제 프로젝트에 적용해보기
- refresh API 연동하기
- 에러 페이지 커스터마이징하기

질문이 있으면 팀 채널에 공유해주세요! 🚀
